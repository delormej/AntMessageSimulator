using System;
using System.Text.RegularExpressions;

namespace AntMessageSimulator
{
    /// <summary>
    /// Represents a message recorded to the ANT device log.
    /// </summary>
    public class Message
    {
        const byte SET_NETWORK_KEY_EVENT = 0x46;
        const byte EVENT_ID_POSITION = 2;
        const byte CHANNEL_ID_POSITION = 3;
        const int MESSAGE_ID_POSTITION = 4;

        private float timestamp;
        private byte[] bytes;
        private string transmitType;

        /// <summary>
        /// Timestamp generated by the ANT Device Log.
        /// </summary>
        public float Timestamp { get { return this.timestamp; } }

        /// <summary>
        /// Either Rx (received message) or Tx (transmitted message).
        /// </summary>
        public string TransmitType { get { return this.transmitType; } }

        /// <summary>
        /// The EventId on a channel, for example SET NETWORK KEY, BROADCAST MESSAGE, etc...
        /// not to be confused with the message id which is the specific command typically
        /// sent over a broadcast or acknowledged event.
        /// </summary>
        public byte EventId { get { return this.bytes[EVENT_ID_POSITION]; } }

        /// <summary>
        /// 0-8 Channel Id the message was sent on.
        /// </summary>
        public byte? ChannelId
        {
            get
            {
                if (IsParseableEvent())
                    return this.bytes[CHANNEL_ID_POSITION];
                else
                    return null;
            }
        }

        /// <summary>
        /// The specific command of the payload.
        /// </summary>
        public byte? MessageId
        {
            get
            {
                if (IsParseableEvent())
                    return this.bytes[MESSAGE_ID_POSTITION];
                else
                    return null;
            }
        }

        public byte[] Bytes { get { return this.bytes; } }

        /// <summary>
        /// Parses a single line from an ANT device log and represents as a Message object.
        /// </summary>
        /// <param name="line"></param>
        /// <returns></returns>
        public static Message MessageFromLine(string line)
        {
            return new Message(line);
        }

        private bool IsParseableEvent()
        {
            return (this.EventId != SET_NETWORK_KEY_EVENT);
        }

        /// <summary>
        /// Parses the timestampe from the left hand side of the '-' in the string.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private float GetTimestamp(string value)
        {
            // data =   135.031 { 673362484} Rx - [A4][09][4E][00][19][2A][FF][C0][00][39][00][31][E7]
            // time =   135.031
            int stopIndex = value.IndexOf('{');

            if (stopIndex <= 0)
                throw new MessageException("Timestamp not found in line: " + value);

            try
            {
                return float.Parse(value.Substring(0, stopIndex - 1));
            }
            catch (Exception parseException)
            {
                throw new MessageException("Timestamp not parseable in: " + value,
                    parseException);
            }
        }

        /// <summary>
        /// Parses the transmit type Tx (transmit) or Rx (receive).
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private string GetTransmitType(string value)
        {
            const int TRANSMIT_TYPE_START_INDEX = 24;
            const int TRANSMIT_TYPE_LENGTH = 2;
            // can be Rx or Tx
            return value.Substring(TRANSMIT_TYPE_START_INDEX, TRANSMIT_TYPE_LENGTH);
        }

        /// <summary>
        /// Left side contains timestamp and transmit type.
        /// </summary>
        /// <param name="value"></param>
        private void ParseTransmitInfo(string value)
        {
            this.timestamp = GetTimestamp(value);
            this.transmitType = GetTransmitType(value);
        }

        /// <summary>
        /// Right side contains the bytes that were on the wire encoded as strings.
        /// </summary>
        /// <param name="value"></param>
        private void ParseMessageBytes(string value)
        {
            string[] stringBytes = Regex.Split(value, @"\]\[");
            this.bytes = new byte[stringBytes.Length];

            for (int i = 0; i < stringBytes.Length; i++)
            {
                try
                {
                    this.bytes[i] = Convert.ToByte(stringBytes[i], 16);
                }
                catch
                {
                    // Ignore any errors.
                    continue;
                }
            }            
        }

        /// <summary>
        /// Sets the internal state of the message object by parsing the line.
        /// </summary>
        /// <param name="line"> Example:
        ///     33.609 {2319281343} Rx - [A4][14][4E][01][01][10][01][00][00][00][02][4B][E0][E6][01][0B][01][10][01][6D][00][3B][A2][4E]
        /// </param>
        /// <exception cref="MessageException">Check inner exception for additional details.</exception>
        private void ParseLine(string line)
        {
            string[] record = line.Split('-'); // Splits into timestamp and hex bytes ascii chars.

            if (record == null || record.Length != 2)
                throw new MessageException("Improperly formatted log line: " + line);

            ParseTransmitInfo(record[0]);
            ParseMessageBytes(record[1]);
        }

        /// <summary>
        /// Creates a message object from a string representing a line in a device log.
        /// </summary>
        /// <param name="line"></param>
        private Message(string line)
        {
            ParseLine(line);
        }

        /// <summary>
        /// Returns a line of executable Auto ANT script.
        /// </summary>
        public string ToAutoAntScriptLine()
        {
            // Example:
            // w  [42][01][10][00]     # Assign channel 0, bidirectional master, network 0
            return null;
        }
    }
}
